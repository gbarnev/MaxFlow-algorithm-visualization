<!DOCTYPE html>
<html>

<head>
	<meta charset="utf-8">
	<title>MaxFlow algorithm</title>
	<script type="text/javascript" src="https://unpkg.com/vis-network/standalone/umd/vis-network.min.js"></script>
	<style type="text/css">
		.graphs {
			height: 500px;
			border: 1px solid lightgray;
		}

		#graphs-flowNetDup {
			columns: 2;
		}

		#buttons-flowNetDup {
			columns: 2;
		}
	</style>
</head>

<body>
	<script src="js/MaxFlow.js"></script>
	<div id="graphs-flowNetDup">
		<div class="graphs" id="flowNet"></div>
		<div class="graphs" hidden=1 id="flowNetDup"></div>
	</div>
	<div id="buttons-flowNetDup">
		<button type="button" onclick="displayRandomGraph()">RANDOM GRAPH</button>
		<button type="button" onclick="runEdmondsKarpAlgorithm()">RUN EDMONDS-KARP</button>
	</div>

	<script type="text/javascript">

		var graph = generateRandomFlowNetwork();
		const nodesVisual = generateVisjsNodes(graph);
		const edgesVisual = generateVisjsEdges(graph);
		var nodesDataSet = new vis.DataSet(nodesVisual);
		var edgesDataSet = new vis.DataSet(edgesVisual);
		var nodesDataSetResidual = new vis.DataSet(nodesVisual);
		var edgesDataSetResidual = new vis.DataSet(edgesVisual);

		// create a network
		var flowNetContainer = document.getElementById('flowNet');
		var flowNetContainerDup = document.getElementById('flowNetDup');
		var data = {
			nodes: nodesDataSet,
			edges: edgesDataSet
		};
		var dataResidual = { nodes: nodesDataSetResidual, edges: edgesDataSetResidual };
		var options = {
			configure:
			{
				enabled: false
			},
			edges:
			{
				arrows:
				{
					to: { enabled: true, scaleFactor: 0.5 }
				}
			},
			physics: {
				enabled: false
			},
			manipulation: {
				enabled: true
			}
		};
		var visNet = new vis.Network(flowNetContainer, data, options);
		var visNetResidual = new vis.Network(flowNetContainerDup, dataResidual, options);

		function generateVisjsNodes(graph) {
			return [...graph.connections.keys()].map(verticeId => {
				return {
					id: verticeId,
					label: "Node " + verticeId
				}
			});
		}

		function generateVisjsEdges(graph) {
			return graph.edges.map(edgeToVisjsEdge);
		}

		function edgeToVisjsEdge(edge) {
			return {
				id: edge.id,
				from: edge.from,
				to: edge.to,
				label: edge.flow + (typeof edge.cap !== 'undefined' ? "/" + edge.cap : ""),
				length: 250,
				smooth: { type: 'curvedCW', roundness: 0.1 }
			}
		}

		function displayRandomGraph() {
			graph = generateRandomFlowNetwork();
			displayOriginalNetwork(graph);
		}

		function displayOriginalNetwork(graph) {
			const nodesVisual = generateVisjsNodes(graph);
			const edgesVisual = generateVisjsEdges(graph);
			nodesDataSet.clear();
			edgesDataSet.clear();
			nodesDataSet.add(nodesVisual);
			edgesDataSet.add(edgesVisual);
			visNet.stabilize();
		}

		function displayResidualNetwork(graph) {
			const nodesVisual = generateVisjsNodes(graph);
			const edgesVisual = generateVisjsEdges(graph);
			nodesDataSetResidual.clear();
			edgesDataSetResidual.clear();
			nodesDataSetResidual.add(nodesVisual);
			edgesDataSetResidual.add(edgesVisual);
			visNetResidual.stabilize();
		}

		async function runEdmondsKarpAlgorithm() {
			for (let step of EdmondsKarp(graph)) {
				await waitMs(1000);
				switch (step.type) {
					case AlgoStatesEnum.INIT_RESIDUAL:
						console.log("INIT_RESIDUAL");
						visualizeInitResidualGraph(step.obj);
						break;
					case AlgoStatesEnum.ADD_EDGE_RESIDUAL:
						console.log("ADD_EDGE_RESIDUAL");
						visualizeAddEdgeToResidualGraph(step.obj);
						break;
					case AlgoStatesEnum.PATH_FOUND_MIN_FLOW_INCREASE:
						console.log("MIN_FLOW_INCREASE");
						await visualizeMinFlowIncrease(step.obj);
						break;
					case AlgoStatesEnum.FINAL_CALC_MAXFLOW:
						console.log("FINAL_CALC_MAXFLOW");
						await visualizeFinalCalculationOfMaxFlow(step.obj);
						break;
					default:
						console.error("Couldn't recognize algorithm step.");
				}
			}
		}

		function visualizeInitResidualGraph(vertices) {
			const container = document.getElementById("flowNetDup");
			if (container.hidden)
				container.hidden = false;

			//Create empty visual graph
			const graph = createGraph(vertices, []);
			displayResidualNetwork(graph);
		}

		function visualizeAddEdgeToResidualGraph(edge) {
			const visJsEdge = edgeToVisjsEdge(edge);
			edgesDataSetResidual.add(visJsEdge);
		}

		async function visualizeMinFlowIncrease(minFlowIncrAndPaths) {
			let minFlowIncr = minFlowIncrAndPaths.flow;
			let pathEdges = minFlowIncrAndPaths.path;
			let pathEdgesResidual = minFlowIncrAndPaths.pathResidual;
			visNetResidual.selectEdges(pathEdgesResidual.map(edge => edge.id));
			await waitMs(1000);
			visNet.selectEdges(pathEdges.map(edge => edge.id));
			await waitMs(1000);
			pathEdges.forEach(edge => edgesDataSet.update({id: edge.id, label: edge.flow + "/" + edge.cap}));
			await waitMs(1000);
			visNet.unselectAll();
			visNetResidual.unselectAll();
		}

		async function visualizeFinalCalculationOfMaxFlow(edgesFromStartAndMaxFlow) {
			let edgesFromStart = edgesFromStartAndMaxFlow.edges;
			let maxFlowResult = edgesFromStartAndMaxFlow.maxFlow;
			visNet.selectEdges(edgesFromStart.map(edge => edge.id));
			await waitMs(1000);
			alert("Max flow is: " + maxFlowResult);
		}

		async function waitMs(ms)
		{
			return new Promise(resolve => setTimeout(resolve, ms));
		}
	</script>
</body>

</html>